<!-- author:lancer
     date:2019/12/19 -->
     <!DOCTYPE html>
     <html>
     <head>
     <meta charset="utf-8">
     <title>剑指offer-21.栈的压入、弹出序列</title>
     <script>

//测试用例
push1=[1,2,3,4,5];
pop1=[4,5,3,2,1];
pop2=[4,3,5,1,2];

console.log(IsPopOrder(push1, pop1));
console.log(IsPopOrder(push1, pop2));

//参考代码
//解法：剑指offer上的做法
function IsPopOrder(pushV, popV)
{
    if(!pushV||pushV.length===0||!popV||popV.length===0||pushV.length!=popV.length)
    return false;
    let ispop=[];//辅助栈
    let popindex=0;//当前判断的弹出顺序的索引
    for(let i=0; i<pushV.length; i++)
    { 
      ispop.push(pushV[i]);
      while((ispop.length!=0)&&(ispop[ispop.length-1]==popV[popindex]))
      {
          ispop.pop();
          popindex++;
      }
    }
    return ispop.length==0;
}


     </script>
     </head>
     
     <body>
     <!-- 
     题目描述：
    输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。
    例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。
    （注意：这两个序列的长度是相等的）
     
     解题思路：
     利用一个辅助栈挨个输入压入顺序序列的数字：如果下一个弹出的数字（弹出序列当前的索引，初始为0）刚好是辅助栈栈顶数字，那么辅助栈
     栈顶数字直接弹出，弹出序列索引+1；如果下一个弹出的数字不在栈顶，则把压栈序列中还没有入栈的数字压入辅助栈，直到下一个需要弹出的
     数字压入栈顶为止；如果所有数字都压入栈后仍然没有找到下一个弹出的数字，那么该序列不可能是一个弹出序列
     
     -->
     </body> 
     
     </html>