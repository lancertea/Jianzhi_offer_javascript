<!-- author:lancer
     date:2019/12/02 -->

<!DOCTYPE html>
 <html>
 <head>
 <meta charset="utf-8">
 <title>剑指offer-3.从尾到头打印链表</title>
<script>

//链表的设计：
//设计链表包含两个类，一个是Node类用来表示节点，另一个是LinkedList类提供插入节点、删除节点等一些操作
//本题要求较简单，可直接用Node类

 function ListNode(x){
     this.val = x;
     this.next = null;
    }


//测试用例
let list = new ListNode(1); 
let a = new ListNode(2);
list.next = a;
let b = new ListNode(3);
a.next = b;
let c = new ListNode(4); 
b.next = c; //初始化一个值为[1,2,3,4]的链表

console.log(printListFromTailToHead1(list));
console.log(printListFromTailToHead2(list));
console.log(printListFromTailToHead3(list));
let array =[]; //易错点：方法四用了一个全局变量，要在调用这个函数前就声明这个全局变量
console.log(printListFromTailToHead4(list));


//参考代码
//解法1：栈的思想（具体见解题思路） 
//最高效的方法，推荐
function printListFromTailToHead1(head)
{  let array =[],
       stack=[];
    while(head){
        array.push(head.val);
        head=head.next;
    }

    while(array.length){
        stack.push(array.pop());
    }
    return stack;
}


//解法2：将链表中的值赋给数组后，对数组进行翻转
function printListFromTailToHead2(head)
{  let res =[];
    while(head){
        res.push(head.val);
        head=head.next;
    }
    return res.reverse();
}



//解法3：利用unshift（）方法从头插入的特性
function printListFromTailToHead3(head)
{  let array =[];
       while(head){
        array.unshift(head.val);
        head=head.next;
    }
    return array;
}

//解法4：递归
//最不推荐的做法
//let array =[]; 
function printListFromTailToHead4(head)
{  
    if(head){
     if(head.next)
        {printListFromTailToHead4(head.next);}
        array.push(head.val);
       }
    return array;
}



     </script>
     </head>
     
     <body>
     <!-- 
     题目描述：
     输入一个链表，按链表从尾到头的顺序返回一个ArrayList。
     
     解题思路：
     解法1：通常打印是一个只读操作，我们不希望打印时修改内容.首先我们想到解决这个问题肯定是要遍历链表，遍历的顺序是从头到尾，可题目要求输出的顺序
     是从尾到头，即第一个遍历到的节点最后一个输出，最后遍历到的节点第一个输出，这就是典型的“后进先出”，可以利用栈实现这种顺序。
     每经过一个节点的时候，就把该节点放到一个栈中，当遍历完整个链表，再从栈顶开始逐个输出节点的值。

     注意：这里是打印列表，所以输出的结果是一个数组

     -->
     </body> 
     
     </html>