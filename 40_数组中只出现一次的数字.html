<!-- author:lancer
     date:2019/12/18 -->
     <!DOCTYPE html>
     <html>
     <head>
     <meta charset="utf-8">
     <title>剑指offer-40.数组中只出现一次的数字</title>
     <script>

//树的结构


//测试用例：
let a=[1,2,3,5,7,2,1,9,5,3];


console.log(FindNumsAppearOnce(a));
//console.log(IsBalanced_Solution(Tree2));

//解法1：位运算
function FindNumsAppearOnce(array)
{
    if(array.length==2) return array;
    let bitresult=0, num=[];
    for(let i=0;i<array.length;i++)
    bitresult^=array[i];
    let index =Findfirst1(bitresult);
    for(let i=0;i<array.length;i++)
    {
        if(isBit1(array[i],index))
           num[0]^=array[i];
        else
           num[1]^=array[i];
        
    }
    return num;

}

function Findfirst1(result)
{
    let index=0;
    while(((result&1)==0)&&index<32)
    {
        result>>=1;
        index++;
    }
    return index;
}

function isBit1(target,index)
{
    return ((target>>index)&1)==1;
}


     </script>
     </head>
     
     <body>
     <!-- 
     题目描述：
     一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字
     
     解题思路：
     

首先：位运算中异或的性质：两个相同数字异或=0，一个数和0异或还是它本身。

当只有一个数出现一次时，我们把数组中所有的数，依次异或运算，最后剩下的就是落单的数，因为成对儿出现的都抵消了。
依照这个思路，我们来看两个数（我们假设是AB）出现一次的数组。我们首先还是先异或，剩下的数字肯定是A、B异或的结果，
这个结果的二进制中的1，表现的是A和B的不同的位。我们就取第一个1所在的位数，假设是第3位，接着把原数组分成两组，分组标准是第3位是否为1。
如此，相同的数肯定在一个组，因为相同数字所有位都相同，而不同的数，肯定不在一组。然后把这两个组按照最开始的思路，
依次异或，剩余的两个结果就是这两个只出现一次的数字。
     
     -->
     </body> 
     
     </html>